配置支持高并发TCP连接的Linux服务器全攻略

分类: linux
日期: 2015-05-25

原文地址: 

http://blog.chinaunix.net/uid-29632145-id-5048461.html

------

****[配置支持高并发TCP连接的Linux服务器全攻略]() *2015-05-25 14:47:08*

分类： LINUX

原文地址：[配置支持高并发TCP连接的Linux服务器全攻略]() 作者：[zimang]()



1、修改用户进程可打开文件数限制
在Linux平台上，无论编写客户端程序还是服务端程序，在 进行高并发TCP连接处理时，最高的并发数量都要受到系统对用户单一进程同时可打开文件数量 的限制(这是因为系统为每个TCP连接都要创建一个socket句柄，每个socket句柄同时也是一个文件句柄)。可使用ulimit命令查看系统允许 当前用户进程打开的文件数限制：
[speng@as4 ~]$ ulimit -n
1024
这表示当前用户的每个进程最多允许 同时打开1024个文件，这1024个文件中还得除去每个进程必然打开的标准输入，标准输出，标准错误，服务器监听 socket，进程间通讯的unix域socket等文件，那么剩下的可用于客户端socket连接的文件数就只有大概1024-10=1014个左右。 也就是说缺省情况下，基于Linux的通讯程序最多允许同时1014个TCP并发连接。

对于想支持更高数量的TCP并发连接的通讯处理程序，就必须修改Linux对当前用户的进程同时打开的文件数量的软限制(soft limit)和硬限制(hardlimit)。其中软限制是指Linux在当前系统能够承受的范围内进一步限制用户同时打开的文件数；硬限制则是根据系统 硬件资源状况(主要是系统内存)计算出来的系统最多可同时打开的文件数量。通常软限制小于或等于硬限制。

修改上述限制的最简单的办法就是使用ulimit命令：
[speng@as4 ~]$ ulimit -n 
上述命令中，在中指定 要设置的单一进程允许打开的最大文件数。如果系统回显类似于“Operation notpermitted”之类的话，说明上述限制修改失败，实际上是因为在中指定的数值超过了Linux系统对该用户 打开文件数的软限制或硬限制。因此，就需要修改Linux系统对用户的关于打开文件数的软限制和硬限制。

第一步，修改/etc/security/limits.conf文件，在文件中添加如下行：
speng soft nofile 10240
speng hard nofile 10240
其中speng指定了要修改哪个用户的打开文件数限制，可用'*'号表示修改所有用户的限制；soft或hard指定要修改软限制还是硬限制；10240则指定了想要修改的新的限制值，即最大打开文件数(请注意软限制值要小于或等于硬限制)。修改完后保存文件。

第二步，修改/etc/pam.d/login文件，在文件中添加如下行：
session required /lib/security/pam_limits.so
这 是告诉Linux在用户完成系统登录后，应该调用pam_limits.so模块来设置系统对该用户可使用的各种资源数量的最大限制(包括用户可打开 的最大文件数限制)，而pam_limits.so模块就会从/etc/security/limits.conf文件中读取配置来设置这些限制值。修改 完后保存此文件。

第三步，查看Linux系统级的最大打开文件数限制，使用如下命令：
[speng@as4 ~]$ cat /proc/sys/fs/file-max
12158
这 表明这台Linux系统最多允许同时打开(即包含所有用户打开文件数总和)12158个文件，是Linux系统级硬限制，所有用户级的打开文件数限制 都不应超过这个数值。通常这个系统级硬限制是Linux系统在启动时根据系统硬件资源状况计算出来的最佳的最大同时打开文件数限制，如果没有特殊需要，不 应该修改此限制，除非想为用户级打开文件数限制设置超过此限制的值。修改此硬限制的方法是修改/etc/rc.local脚本，在脚本中添加如下行：
echo 22158 > /proc/sys/fs/file-max
这是让Linux在启动完成后强行将系统级打开文件数硬限制设置为22158。修改完后保存此文件。

完成上述步骤后重启系统，一般情况下就可以将Linux系统对指定用户的单一进程允许同时打开的最大文件数限制设为指定的数值。如果重启后用 ulimit-n命令查看用户可打开文件数限制仍然低于上述步骤中设置的最大值，这可能是因为在用户登录脚本/etc/profile中使用ulimit -n命令已经将用户可同时打开的文件数做了限制。由于通过ulimit-n修改系统对用户可同时打开文件的最大数限制时，新修改的值只能小于或等于上次 ulimit-n设置的值，因此想用此命令增大这个限制值是不可能的。所以，如果有上述问题存在，就只能去打开/etc/profile脚本文件，在文件 中查找是否使用了ulimit-n限制了用户可同时打开的最大文件数量，如果找到，则删除这行命令，或者将其设置的值改为合适的值，然后保存文件，用户退 出并重新登录系统即可。
通过上述步骤，就为支持高并发TCP连接处理的通讯处理程序解除关于打开文件数量方面的系统限制。

2、修改网络内核对TCP连接的有关限制

在Linux上编写支持高并发TCP连接的客户端通讯处理程序时，有时会发现尽管已经解除了系统对用户同时打开文件数的限制，但仍会出现并发TCP连接数增加到一定数量时，再也无法成功建立新的TCP连接的现象。出现这种现在的原因有多种。

第一种原因可能是因为Linux网络内核对本地端口号范围有限制。此时，进一步分析为什么无法建立TCP连接，会发现问题出在connect()调 用返 回失败，查看系统错误提示消息是“Can't assign requestedaddress”。同时，如果在此时用tcpdump工具监视网络，会发现根本没有TCP连接时客户端发SYN包的网络流量。这些情况 说明问题在于本地Linux系统内核中有限制。其实，问题的根本原因在于Linux内核的TCP/IP协议实现模块对系统中所有的客户端TCP连接对应的 本地端口号的范围进行了限制(例如，内核限制本地端口号的范围为1024~32768之间)。当系统中某一时刻同时存在太多的TCP客户端连接时，由于每 个TCP客户端连接都要占用一个唯一的本地端口号(此端口号在系统的本地端口号范围限制中)，如果现有的TCP客户端连接已将所有的本地端口号占满，则此 时就无法为新的TCP客户端连接分配一个本地端口号了，因此系统会在这种情况下在connect()调用中返回失败，并将错误提示消息设为“Can't assignrequested address”。有关这些控制逻辑可以查看Linux内核源代码，以linux2.6内核为例，可以查看tcp_ipv4.c文件中如下函数：
static int tcp_v4_hash_connect(struct sock *sk)
请注意上述函数中对变量sysctl_local_port_range的访问控制。变量sysctl_local_port_range的初始化则是在tcp.c文件中的如下函数中设置：
void __init tcp_init(void)
内核编译时默认设置的本地端口号范围可能太小，因此需要修改此本地端口范围限制。
第一步，修改/etc/sysctl.conf文件，在文件中添加如下行：
net.ipv4.ip_local_port_range = 1024 65000
这表明将系统对本地端口范围限制设置为1024~65000之间。请注意，本地端口范围的最小值必须大于或等于1024；而端口范围的最大值则应小于或等于65535。修改完后保存此文件。
第二步，执行sysctl命令：
[speng@as4 ~]$ sysctl -p
如果系统没有错误提示，就表明新的本地端口范围设置成功。如果按上述端口范围进行设置，则理论上单独一个进程最多可以同时建立60000多个TCP客户端连接。

第二种无法建立TCP连接的原因可能是因为Linux网络内核的IP_TABLE防火墙对最大跟踪的TCP连接数有限制。此时程序会表现为在 connect()调用中阻塞，如同死机，如果用tcpdump工具监视网络，也会发现根本没有TCP连接时客户端发SYN包的网络流量。由于 IP_TABLE防火墙在内核中会对每个TCP连接的状态进行跟踪，跟踪信息将会放在位于内核内存中的conntrackdatabase中，这个数据库 的大小有限，当系统中存在过多的TCP连接时，数据库容量不足，IP_TABLE无法为新的TCP连接建立跟踪信息，于是表现为在connect()调用 中阻塞。此时就必须修改内核对最大跟踪的TCP连接数的限制，方法同修改内核对本地端口号范围的限制是类似的：
第一步，修改/etc/sysctl.conf文件，在文件中添加如下行：
net.ipv4.ip_conntrack_max = 10240
这表明将系统对最大跟踪的TCP连接数限制设置为10240。请注意，此限制值要尽量小，以节省对内核内存的占用。
第二步，执行sysctl命令：
[speng@as4 ~]$ sysctl -p
如果系统没有错误提示，就表明系统对新的最大跟踪的TCP连接数限制修改成功。如果按上述参数进行设置，则理论上单独一个进程最多可以同时建立10000多个TCP客户端连接。

3、使用支持高并发网络I/O的编程技术

在Linux上编写高并发TCP连接应用程序时，必须使用合适的网络I/O技术和I/O事件分派机制。

可用的I/O技术有同步I/O，非阻塞式同步I/O(也称反应式I/O)，以及异步I/O。在高TCP并发的情形下，如果使用同步I/O，这会严重 阻塞 程序的运转，除非为每个TCP连接的I/O创建一个线程。但是，过多的线程又会因系统对线程的调度造成巨大开销。因此，在高TCP并发的情形下使用同步 I/O是不可取的，这时可以考虑使用非阻塞式同步I/O或异步I/O。非阻塞式同步I/O的技术包括使用select()，poll()，epoll等机 制。异步I/O的技术就是使用AIO。

从I/O事件分派机制来看，使用select()是不合适的，因为它所支持的并发连接数有限(通常在1024个以内)。如果考虑性能，poll() 也是 不合适的，尽管它可以支持的较高的TCP并发数，但是由于其采用“轮询”机制，当并发数较高时，其运行效率相当低，并可能存在I/O事件分派不均，导致部 分TCP连接上的I/O出现“饥饿”现象。而如果使用epoll或AIO，则没有上述问题(早期Linux内核的AIO技术实现是通过在内核中为每个 I/O请求创建一个线程来实现的，这种实现机制在高并发TCP连接的情形下使用其实也有严重的性能问题。但在最新的Linux内核中，AIO的实现已经得 到改进)。

综上所述，在开发支持高并发TCP连接的Linux应用程序时，应尽量使用epoll或AIO技术来实现并发的TCP连接上的I/O控制，这将为提升程序对高并发TCP连接的支持提供有效的I/O保证。

Date: 2007-01-31
OS: Red Hat Enterprise Linux AS release 4 (kernel version 2.6.9-5.EL)

 

 网上关于sysctl.conf的优化方案有各种版本，大多都是抄来抄去的，让新人看了很迷茫。为解决此问题，经过两天的整理，查了N多资料，将 大 家常用的总结如下，很多默认的不需要修改的暂未涉及，今后将逐步把所有的项目都有个翻译、讲解、修改建议，如有修改，将以此文为准，其他地方的内容，本人 不负责更新。

\###################
所有rfc相关的选项都是默认启用的，因此网上的那些还自己写rfc支持的都可以扔掉了:)
\###############################

net.inet.ip.sourceroute=0
net.inet.ip.accept_sourceroute=0
\#############################
通过源路由，攻击者可以尝试到达内部IP地址 --包括RFC1918中的地址，所以
不接受源路由信息包可以防止你的内部网络被探测。
\#################################

net.inet.tcp.drop_synfin=1
\###################################
安全参数，编译内核的时候加了options TCP_DROP_SYNFIN才可以用，可以阻止某些OS探测。
\##################################

kern.maxfiles: 1928
\#################http://www.bsdlover.cn#########
系统中支持最多同时开启的文件数量，如果你在运行数据库或大的很吃描述符的进程，那么应该设置在20000以上，
比如kde这样的桌面环境，它同时要用的文件非常多。
一般推荐设置为32768或者65536。
\####################################

kern.argmax: 262144
\#################http://www.bsdlover.cn#########
maximum number of bytes (or characters) in an argument list.
命令行下最多支持的参数，比如你在用find命令来批量删除一些文件的时候
find . -name "*.old" -delete，如果文件数超过了这个数字，那么会提示你数字太多的。
可以利用find . -name "*.old" -ok rm {} \;来删除。
默认的参数已经足够多了，因此不建议再做修改。
\####################################

kern.securelevel: -1
\#################http://www.bsdlover.cn#########
-1：这是系统默认级别，没有提供任何内核的保护错误； 
0：基本上作用不多，当你的系统刚启动就是0级别的，当进入多用户模式的时候就自动变成1级了。 
1：在这个级别上，有如下几个限制： 
a. 不能通过kldload或者kldunload加载或者卸载可加载内核模块； 
b. 应用程序不能通过/dev/mem或者/dev/kmem直接写内存； 
c. 不能直接往已经装在(mounted)的磁盘写东西，也就是不能格式化磁盘，但是可以通过标准的内核接口执行写操作； 
d. 不能启动X-windows，同时不能使用chflags来修改文件属性； 
2：在 1 级别的基础上还不能写没装载的磁盘，而且不能在1秒之内制造多次警告，这个是防止DoS控制台的； 
3：在 2 级别的级别上不允许修改IPFW防火墙的规则。 
如果你已经装了防火墙，并且把规则设好了，不轻易改动，那么建议使用3级别，如果你没有装防火墙，而且还准备装防火墙的话，不建议使用。
我们这里推荐使用 2 级别，能够避免比较多对内核攻击。
\####################################

kern.maxfilesperproc: 1735
\#################http://www.bsdlover.cn#########
每个进程能够同时打开的最大文件数量，网上很多资料写的是32768
除非用异步I/O或大量线程，打开这么多的文件恐怕是不太正常的。
我个人建议不做修改，保留默认。
\####################################

kern.ipc.maxsockbuf: 262144
\#################http://www.bsdlover.cn#########
最大的套接字缓冲区，网上有建议设置为2097152（2M）、8388608（8M）的。
我个人倒是建议不做修改，保持默认的256K即可，缓冲区大了可能造成碎片、阻塞或者丢包。
\####################################

kern.ipc.somaxconn: 128
\#################http://www.bsdlover.cn#########
最大的等待连接完成的套接字队列大小，即并发连接数。
高负载服务器和受到Dos攻击的系统也许会因为这个队列被塞满而不能提供正常服务。
默认为128，推荐在1024-4096之间，根据机器和实际情况需要改动，数字越大占用内存也越大。
\####################################

kern.ipc.nmbclusters: 4800
\#################http://www.bsdlover.cn#########
这个值用来调整系统在开机后所要分配给网络 mbufs 的 cluster 数量，
由于每个 cluster 大小为 2K，所以当这个值为 1024 时，也是会用到 2MB 的核心内存空间。
假设我们的网页同时约有 1000 个联机，而 TCP 传送及接收的暂存区大小都是 16K，
则最糟的情况下，我们会需要 (16K+16K) * 1024，也就是 32MB 的空间，
然而所需的 mbufs 大概是这个空间的二倍，也就是 64MB，所以所需的 cluster 数量为 64MB/2K，也就是 32768。
对于内存有限的机器，建议值是 1024 到 4096 之间，而当拥有海量存储器空间时，我们可以将它设定为 4096 到 32768 之间。
我们可以使用 netstat 这个指令并加上参数 -m 来查看目前所使用的 mbufs 数量。
要修改这个值必须在一开机就修改，所以只能在 /boot/loader.conf 中加入修改的设定
kern.ipc.nmbclusters=32768
\####################################

kern.ipc.shmmax: 33554432
\#################http://www.bsdlover.cn#########
共享内存和信号灯("System VIPC")如果这些过小的话，有些大型的软件将无法启动
安装xine和mplayer提示的设置为67108864，即64M，
如果内存多的话，可以设置为134217728，即128M
\####################################

kern.ipc.shmall: 8192
\#################http://www.bsdlover.cn#########
共享内存和信号灯("System VIPC")如果这些过小的话，有些大型的软件将无法启动
安装xine和mplayer提示的设置为32768
\####################################

kern.ipc.shm_use_phys: 0
\#################http://www.bsdlover.cn#########
如果我们将它设成 1，则所有 System V 共享内存 (share memory，一种程序间沟通的方式)部份都会被留在实体的内存 (physical memory) 中，
而不会被放到硬盘上的 swap 空间。我们知道物理内存的存取速度比硬盘快许多，而当物理内存空间不足时，
部份数据会被放到虚拟的内存上，从物理内存和虚拟内存之间移转的动作就叫作 swap。如果时常做 swap 的动作，
则需要一直对硬盘作 I/O，速度会很慢。因此，如果我们有大量的程序 (数百个) 需要共同分享一个小的共享内存空间，
或者是共享内存空间很大时，我们可以将这个值打开。
这一项，我个人建议不做修改，除非你的内存非常大。
\####################################

kern.ipc.shm_allow_removed: 0
\#################http://www.bsdlover.cn#########
共享内存是否允许移除？这项似乎是在fb下装vmware需要设置为1的，否则会有加载SVGA出错的提示
作为服务器，这项不动也罢。
\####################################

kern.ipc.numopensockets: 12
\#################http://www.bsdlover.cn#########
已经开启的socket数目，可以在最繁忙的时候看看它是多少，然后就可以知道maxsockets应该设置成多少了。
\####################################

kern.ipc.maxsockets: 1928
\#################http://www.bsdlover.cn#########
这是用来设定系统最大可以开启的 socket 数目。如果您的服务器会提供大量的 FTP 服务，
而且常快速的传输一些小档案，您也许会发现常传输到一半就中断。因为 FTP 在传输档案时，
每一个档案都必须开启一个 socket 来传输，但关闭 socket 需要一段时间，如果传输速度很快，
而档案又多，则同一时间所开启的 socket 会超过原本系统所许可的值，这时我们就必须把这个值调大一点。
除了 FTP 外，也许有其它网络程序也会有这种问题。
然而，这个值必须在系统一开机就设定好，所以如果要修改这项设定，我们必须修改 /boot/loader.conf 才行
kern.ipc.maxsockets="16424"
\####################################

kern.ipc.nsfbufs: 1456
\#################http://www.bsdlover.cn#########
经常使用 sendfile(2) 系统调用的繁忙的服务器， 
有必要通过 NSFBUFS 内核选项或者在 /boot/loader.conf (查看 loader(8) 以获得更多细节) 中设置它的值来调节 sendfile(2) 缓存数量。
这个参数需要调节的普通原因是在进程中看到 sfbufa 状态。sysctl kern.ipc.nsfbufs 变量在内核配置变量中是只读的。 
这个参数是由 kern.maxusers 决定的，然而它可能有必要因此而调整。
在/boot/loader.conf里加入
kern.ipc.nsfbufs="2496"
\####################################

kern.maxusers: 59
\#################http://www.bsdlover.cn#########
maxusers 的值决定了处理程序所容许的最大值，20+16*maxusers 就是你将得到的所容许处理程序。
系统一开机就必须要有 18 个处理程序 (process)，即便是简单的执行指令 man 又会产生 9 个 process，
所以将这个值设为 64 应该是一个合理的数目。
如果你的系统会出现 proc table full 的讯息的话，可以就把它设大一点，例如 128。
除非您的系统会需要同时开启很多档案，否则请不要设定超过 256。

可以在 /boot/loader.conf 中加入该选项的设定，
kern.maxusers=256
\####################################

kern.coredump: 1
\#################http://www.bsdlover.cn#########
如果设置为0，则程序异常退出时不会生成core文件，作为服务器，不建议这样。
\####################################

kern.corefile: %N.core
\#################http://www.bsdlover.cn#########
可设置为kern.corefile="/data/coredump/%U-%P-%N.core"
其中 %U是UID，%P是进程ID，%N是进程名，当然/data/coredump必须是一个实际存在的目录
\####################################

vm.swap_idle_enabled: 0
vm.swap_idle_threshold1: 2
vm.swap_idle_threshold2: 10
\#########################
在有很多用户进入、离开系统和有很多空闲进程的大的多用户系统中很有用。
可以让进程更快地进入内存，但它会吃掉更多的交换和磁盘带宽。
系统默认的页面调度算法已经很好了，最好不要更改。
\########################

vfs.ufs.dirhash_maxmem: 2097152
\#########################
默认的dirhash最大内存,默认2M
增加它有助于改善单目录超过100K个文件时的反复读目录时的性能
建议修改为33554432（32M）
\#############################

vfs.vmiodirenable: 1
\#################
这个变量控制目录是否被系统缓存。大多数目录是小的，在系统中只使用单个片断(典型的是1K)并且在缓存中使用的更小 (典型的是512字节)。
当这个变量设置为关闭 (0) 时，缓存器仅仅缓存固定数量的目录，即使您有很大的内存。 
而将其开启 (设置为1) 时，则允许缓存器用 VM 页面缓存来缓存这些目录，让所有可用内存来缓存目录。
不利的是最小的用来缓存目录的核心内存是大于 512 字节的物理页面大小(通常是 4k)。
我们建议如果您在运行任何操作大量文件的程序时保持这个选项打开的默认值。 
这些服务包括 web 缓存，大容量邮件系统和新闻系统。
尽管可能会浪费一些内存，但打开这个选项通常不会降低性能。但还是应该检验一下。
\####################

vfs.hirunningspace: 1048576
\############################
这个值决定了系统可以将多少数据放在写入储存设备的等候区。通常使用默认值即可，
但当我们有多颗硬盘时，我们可以将它调大为 4MB 或 5MB。
注意这个设置成很高的值(超过缓存器的写极限)会导致坏的性能。
不要盲目的把它设置太高！高的数值会导致同时发生的读操作的迟延。
\#############################

vfs.write_behind: 1
\#########################
这个选项预设为 1，也就是打开的状态。在打开时，在系统需要写入数据在硬盘或其它储存设备上时，
它会等到收集了一个 cluster 单位的数据后再一次写入，否则会在一个暂存区空间有写入需求时就立即写到硬盘上。
这个选项打开时，对于一个大的连续的文件写入速度非常有帮助。但如果您遇到有很多行程延滞在等待写入动作时，您可能必须关闭这个功能。
\############################

net.inet.ip.portrange.lowfirst: 1023
net.inet.ip.portrange.lowlast: 600
net.inet.ip.portrange.first: 49152
net.inet.ip.portrange.last: 65535
net.inet.ip.portrange.hifirst: 49152
net.inet.ip.portrange.hilast: 65535
\###################
以上六项是用来控制TCP及UDP所使用的port范围，这个范围被分成三个部份，低范围、预设范围、及高范围。
这些是你的服务器主动发起连接时的临时端口的范围，预设的已经1万多了，一般的应用就足够了。
如果是比较忙碌的FTP server，一般也不会同时提供给1万多人访问的，
当然如果很不幸，你的服务器就要提供很多，那么可以修改first的值，比如直接用1024开始
\#########################

net.inet.ip.redirect: 1
\#########################
设置为0，屏蔽ip重定向功能
\###########################

net.inet.ip.rtexpire: 3600
net.inet.ip.rtminexpire: 10
\########################
很多apache产生的CLOSE_WAIT状态，这种状态是等待客户端关闭，但是客户端那边并没有正常的关闭，于是留下很多这样的东东。
建议都修改为2
\#########################

net.inet.ip.fastforwarding: 0
\#############################
如果打开的话每个目标地址一次转发成功以后它的数据都将被记录进路由表和arp数据表，节约路由的计算时间
但会需要大量的内核内存空间来保存路由表。
如果内存够大，打开吧，呵呵
\#############################

net.inet.ip.random_id: 0
\#####################
默认情况下，ip包的id号是连续的，而这些可能会被攻击者利用，比如可以知道你nat后面带了多少主机。
如果设置成1，则这个id号是随机的，嘿嘿。
\#####################

net.inet.icmp.maskrepl: 0
\############################
防止广播风暴，关闭其他广播探测的响应。默认即是，无须修改。
\###############################

net.inet.tcp.mssdflt: 512
net.inet.tcp.minmss: 216
\###############################
数据包数据段最小值，以上两个选项最好不动！或者只修改mssdflt为1460，minmss不动。

\#############################

net.inet.tcp.keepidle: 7200000
\######################
TCP的套接字的空闲时间，默认时间太长，可以改为600000（10分钟）。
\##########################

net.inet.tcp.log_in_vain: 0
\##################
记录下任何TCP连接，这个一般情况下不应该更改。
\####################

net.inet.tcp.blackhole: 0
\##################################
建议设置为2，接收到一个已经关闭的端口发来的所有包，直接drop，如果设置为1则是只针对TCP包
\#####################################

net.inet.tcp.delayed_ack: 1
\###########################
当一台计算机发起TCP连接请求时，系统会回应ACK应答数据包。
该选项设置是否延迟ACK应答数据包，把它和包含数据的数据包一起发送。
在高速网络和低负载的情况下会略微提高性能，但在网络连接较差的时候，
对方计算机得不到应答会持续发起连接请求，反而会让网络更加拥堵，降低性能。
因此这个值我建议您看情况而定，如果您的网速不是问题，可以将封包数量减少一半
如果网络不是特别好，那么就设置为0，有请求就先回应，这样其实浪费的网通、电信的带宽速率而不是你的处理时间:)
\############################

net.inet.tcp.inflight.enable: 1
net.inet.tcp.inflight.debug: 0
net.inet.tcp.inflight.rttthresh: 10
net.inet.tcp.inflight.min: 6144
net.inet.tcp.inflight.max: 1073725440
net.inet.tcp.inflight.stab: 20
\###########################
限制 TCP 带宽延迟积和 NetBSD 的 TCP/Vegas 类似。 
它可以通过将 sysctl 变量 net.inet.tcp.inflight.enable 设置成 1 来启用。 
系统将尝试计算每一个连接的带宽延迟积，并将排队的数据量限制在恰好能保持最优吞吐量的水平上。
这一特性在您的服务器同时向使用普通调制解调器，千兆以太网，乃至更高速度的光与网络连接 (或其他带宽延迟积很大的连接) 的时候尤为重要，
特别是当您同时使用滑动窗缩放，或使用了大的发送窗口的时候。 
如果启用了这个选项，您还应该把 net.inet.tcp.inflight.debug 设置为 0 (禁用调试)，
对于生产环境而言， 将 net.inet.tcp.inflight.min 设置成至少 6144 会很有好处。 
然而， 需要注意的是，这个值设置过大事实上相当于禁用了连接带宽延迟积限制功能。
这个限制特性减少了在路由和交换包队列的堵塞数据数量，也减少了在本地主机接口队列阻塞的数据的数量。
在少数的等候队列中、交互式连接，尤其是通过慢速的调制解调器，也能用低的 往返时间操作。
但是，注意这只影响到数据发送 (上载/服务端)。对数据接收(下载)没有效果。
调整 net.inet.tcp.inflight.stab 是 不 推荐的。
这个参数的默认值是 20，表示把 2 个最大包加入到带宽延迟积窗口的计算中。 
额外的窗口似的算法更为稳定，并改善对于多变网络环境的相应能力， 
但也会导致慢速连接下的 ping 时间增长 (尽管还是会比没有使用 inflight 算法低许多)。 
对于这些情形， 您可能会希望把这个参数减少到 15， 10， 或 5； 
并可能因此而不得不减少 net.inet.tcp.inflight.min (比如说， 3500) 来得到希望的效果。
减少这些参数的值， 只应作为最后不得已时的手段来使用。
\############################

net.inet.tcp.syncookies: 1
\#########################
SYN cookies是一种用于通过选择加密的初始化TCP序列号，可以对回应的包做验证来降低SYN'洪水'攻击的影响的技术。
默认即是，不需修改
\########################

net.inet.udp.checksum: 1
\#########################
防止不正确的udp包的攻击，默认即是，不需修改
\##############################

net.inet.udp.log_in_vain: 0
\#######################
记录下任何UDP连接,这个一般情况下不应该修改。
\#######################

net.inet.udp.blackhole: 0
\####################
建议设置为1，接收到一个已经关闭的端口发来的所有UDP包直接drop
\#######################

net.link.ether.inet.max_age: 1200
\####################
调整ARP清理的时间，通过向IP路由缓冲填充伪造的ARP条目可以让恶意用户产生资源耗竭和性能减低攻击。
这项似乎大家都未做改动，我建议不动或者稍微减少，比如300（HP-UX默认的5分钟）
\#######################

net.inet6.ip6.redirect: 1
\###############################
设置为0，屏蔽ipv6重定向功能
\###########################

net.isr.direct: 0
\#################http://www.bsdlover.cn#########
所有MPSAFE的网络ISR对包做立即响应,提高网卡性能，设置为1。
\####################################

hw.ata.wc: 1
\#####################
这个选项用来打开 IDE 硬盘快取。当打开时，如果有数据要写入硬盘时，硬盘会假装已完成写入，并将数据快取起来。
这种作法会加速硬盘的存取速度，但当系统异常关机时，比较容易造成数据遗失。
不过由于关闭这个功能所带来的速度差异实在太大，建议还是保留原本打开的状态吧，不做修改。
\###################

security.bsd.see_other_uids: 1
security.bsd.see_other_gids: 1
\#####################
不允许用户看到其他用户的进程,因此应该改成0，
\#######################
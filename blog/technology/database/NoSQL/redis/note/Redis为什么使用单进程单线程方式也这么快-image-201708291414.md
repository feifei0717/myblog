# Redis为什么使用单进程单线程方式也这么快

[转] <http://www.syyong.com/db/Redis-why-the-use-of-single-process-and-single-threaded-way-so-fast.html>

Redis采用的是基于内存的采用的是单进程单线程模型的KV数据库，由C语言编写。官方提供的数据是可以达到100000+的qps。这个数据不比采用单进程多线程的同样基于内存的KV数据库Memcached差。

Redis快的主要原因是：

1. 完全基于内存
2. 数据结构简单，对数据操作也简单
3. 使用多路 I/O 复用模型

第一、二点不细讲，主要围绕第三点采用多路 I/O 复用技术来展开。

多路 I/O 复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。

![](image-201708291414/3587411016.png)

和Memcached不同，Redis并没有直接使用Libevent，而是自己完成了一个非常轻量级的对select、epoll、evport、kqueue这些通用的接口的实现。在不同的系统调用选用适合的接口，linux下默认是epoll。因为Libevent比较重更通用代码量也就很庞大，拥有很多Redis用不上的功能，Redis为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。

### 单进程单线程好处

1. 代码更清晰，处理逻辑更简单
2. 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
3. 不存在多进程或者多线程导致的切换而消耗CPU

### 单进程单线程弊端

1. 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；

### 其他一些优秀的开源软件采用的模型

- 多进程单线程模型：Nginx
- 单进程多线程模型：Memcached

### 参考链接

- <https://en.wikipedia.org/wiki/Epoll>
- <https://segmentfault.com/a/1190000003063859#articleHeader6>
- [<http://www.ibm.com/developerworks/cn/linux/l-async/]http://www.ibm.com/developerworks/cn/linux/l-async/>
- <http://www.syyong.com/db/Redis-why-the-use-of-single-process-and-single-threaded-way-so-fast.html>
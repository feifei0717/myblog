# java位运算 与或非异或



 

## **位运算**

### 简介

位运算符包括:　与（&）、非（~）、或（|）、异或（^）

- &：当两边操作数的位同时为1时，结果为1，否则为0。如1100&1010=1000 　　

- | ：当两边操作数的位有一边为1时，结果为1，否则为0。如1100|1010=1110 　　

- ​ ~：0变1,1变0 　　

- ​ ^：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0.如1100^1010=0110


 

### 实例

位运算与位移动运行符的一个场景:

HashMap的功能是通过“键(key)”能够快速的找到“值”。下面我们分析下HashMap存数据的基本流程： 

1、当调用put(key,value)时，首先获取key的hashcode，int hash = key.hashCode(); 

2、再把hash通过一下运算得到一个int h. 
hash ^= (hash >>> 20) ^ (hash >>> 12); 
int h = hash ^ (hash >>> 7) ^ (hash >>> 4); 
为什么要经过这样的运算呢？这就是HashMap的高明之处。先看个例子，一个十进制数32768(二进制1000 0000 0000 0000)，经过上述公式运算之后的结果是35080(二进制1000 1001 0000 1000)。看出来了吗？或许这样还看不出什么，再举个数字61440(二进制1111 0000 0000 0000)，运算结果是65263(二进制1111 1110 1110 1111)，现在应该很明显了，**它的目的是让“1”变的均匀一点，散列的本意就是要尽量均匀分布**。

3、得到h之后，把h与HashMap的承载量（HashMap的默认承载量length是16，可以自动变长。在构造HashMap的时候也可以指定一个长 度。这个承载量就是上图所描述的数组的长度。）进行逻辑与运算，**即(length-1)& h，这样得到的结果就是一个比length小的正数，我们把这个值叫做index。其实这个index就是索引将要插入的值在数组中的 位置**。第2步那个算法的意义就是希望能够得出均匀的index，这是HashTable的改进，HashTable中的算法只是把key的 hashcode与length相除取余，即hash % length，这样有可能会造成index分布不均匀。还有一点需要说明，HashMap的键可以为null，它的值是放在数组的第一个位置。

4、我们用table[index]表示已经找到的元素需要存储的位置。先判断该位置上有没有元素（这个元素是HashMap内部定义的一个类Entity， 基本结构它包含三个类，key，value和指向下一个Entity的next）,没有的话就创建一个Entity对象，在 table[index]位置上插入，这样插入结束；如果有的话，通过链表的遍历方式去逐个遍历，看看有没有已经存在的key，有的话用新的value替 换老的value；如果没有，则在table[index]插入该Entity，把原来在table[index]位置上的Entity赋值给新的 Entity的next，这样插入结束。

 

**附:hashmap是列表与链表的结合体.**

参:http://www.cnblogs.com/highriver/archive/2011/08/15/2139462.html

\----------------------------------------------------------------------------

 

转自http://www.iteye.com/topic/766461

## **移位运算符**

### 简介

java移位运算符不外乎就这三种：<<（左移）、>>（带符号右移）和>>>（无符号右移）。  

<<表示左移, 左移一位表示原来的值乘2.

同理,>>表示右移. 右移一位表示除2.

### **1、 左移运算符** 

左移运算符<<使指定值的所有位都左移规定的次数。 
1）它的通用格式如下所示： 
value << num 
num 指定要移位值value 移动的位数。 
左移的规则只记住一点：丢弃最高位，0补最低位 
如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如对int型移动33位，实际上只移动了33%32=1位。 
2）运算规则 
按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补零。 
当左移的运算数是int 类型时，每移动1位它的第31位就要被移出并且丢弃； 
当左移的运算数是long 类型时，每移动1位它的第63位就要被移出并且丢弃。 
当左移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。 
3）数学意义 
在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方 
4）计算过程： 
例如：3 <<2(3为int型) 
1）把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011， 
2）把该数字高位(左侧)的两个零移出，其他的数字都朝左平移2位， 
3）在低位(右侧)的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100， 
转换为十进制是12。 
移动的位数超过了该类型的最大位数， 
如果移进高阶位（31或63位），那么该值将变为负值。下面的程序说明了这一点：

Java代码  

1. // Left shifting as a quick way to multiply by 2.  
2. public class MultByTwo {  
3. public static void main(String args[]) {  
4. int i;  
5. int num = 0xFFFFFFE;   
6. for(i=0; i<4; i++) {  
7. ​       num = num << 1;   
8. ​     System.out.println(num);  
9. }  
10. }  
11. }  

```
// Left shifting as a quick way to multiply by 2.
public class MultByTwo {
public static void main(String args[]) {
   int i;
   int num = 0xFFFFFFE; 
   for(i=0; i<4; i++) {
       num = num << 1; 
     System.out.println(num);
   }
  }
}
```

该程序的输出如下所示： 
536870908 
1073741816 
2147483632 
-32 
注：n位二进制，最高位为符号位，因此表示的数值范围-2^(n-1) ——2^(n-1) -1,所以模为2^(n-1)。 

### **2、 右移运算符** 



右移运算符<<使指定值的所有位都右移规定的次数。 
1）它的通用格式如下所示： 
value >> num 
num 指定要移位值value 移动的位数。 
右移的规则只记住一点：符号位不变，左边补上符号位 
2）运算规则： 
按二进制形式把所有的数字向右移动对应的位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1 
当右移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。 
例如，如果要移走的值为负数，每一次右移都在左边补1，如果要移走的值为正数，每一次右移都在左边补0，这叫做符号位扩展（保留符号位）（sign extension ），在进行右移 
操作时用来保持负数的符号。 
3）数学意义 
右移一位相当于除2，右移n位相当于除以2的n次方。 
4）计算过程 
11 >>2(11为int型) 
1)11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 1011 
2)把低位的最后两个数字移出，因为该数字是正数，所以在高位补零。 
3)最终结果是0000 0000 0000 0000 0000 0000 0000 0010。 
转换为十进制是2。 
35 >> 2(35为int型) 
35转换为二进制：0000 0000 0000 0000 0000 0000 0010 0011  
把低位的最后两个数字移出：0000 0000 0000 0000 0000 0000 0000 1000 
转换为十进制： 8 
5）在右移时不保留符号的出来 
右移后的值与0x0f进行按位与运算，这样可以舍弃任何的符号位扩展，以便得到的值可以作为定义数组的下标，从而得到对应数组元素代表的十六进制字符。 
例如

Java代码  

1. public class HexByte {  
2. public static public void main(String args[]) {  
3. char hex[] = {  
4. '0', '1', '2', '3', '4', '5', '6', '7',   
5. '8', '9', 'a', 'b', 'c', 'd', 'e', 'f''   
6. };  
7. byte b = (byte) 0xf1;   
8. System.out.println("b = 0x" + hex[(b >> 4) & 0x0f] + hex[b & 0x0f]);  
9. }  
10. }   

```
public class HexByte {
public static public void main(String args[]) {
char hex[] = {
'0', '1', '2', '3', '4', '5', '6', '7', 
'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'' 
};
byte b = (byte) 0xf1; 
System.out.println("b = 0x" + hex[(b >> 4) & 0x0f] + hex[b & 0x0f]);
}
} 
```

(b >> 4) & 0x0f的运算过程： 
b的二进制形式为：1111 0001 
4位数字被移出：0000 1111 
按位与运算:0000 1111 
转为10进制形式为：15 
b & 0x0f的运算过程： 
b的二进制形式为：1111 0001 
0x0f的二进制形式为：0000 1111 
按位与运算：0000 0001 
转为10进制形式为：1 
所以，该程序的输出如下： 
b = 0xf1 

### **3、无符号右移** 

无符号右移运算符>>>
它的通用格式如下所示： 
value >>> num 
num 指定要移位值value 移动的位数。 
无符号右移的规则只记住一点：**忽略了符号位扩展，0补最高位 **
**无符号右移运算符>>> 只是对32位和64位的值有意义**





原文地址: <http://blog.chinaunix.net/uid-29632145-id-4492794.html>